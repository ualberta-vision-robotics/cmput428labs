---
layout: page
title: Lab 1.1 Optical Flow
description:
permalink: /labs/opticalflow
img: assets/img/opticalflow.gif
importance: 1
category: Motion Estimation and Tracking
related_publications: false
---

<div class="row justify-content-md-center">
    <div class="col-sm-3 mt-4 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/opticalflow.gif" title="optical flow" class="img-fluid rounded z-depth-1"  %}
    </div>
</div>
<div class="caption">
    2 DOF optical flow on a soccer ball.
</div>

In this lab, you'll learn the basics of optical flow. These vectors describe the motion in a scene.

$$I(x, y, t)$$ gives the intensity at a point over time. We can approximate how the image intensity function changes over time with a Taylor series expansion:



$$
I(x+u, y+v, t+\Delta t)=I(x, y, t)+\frac{\partial I}{\partial x} u+\frac{\partial I}{\partial y} v+\frac{\partial I}{\partial t} \Delta t+\text { h.o.t. }
$$

With the brightness constancy and small motion assumptions, we can cancel out $$I$$ from both sides, yielding:

$$
-\frac{\partial I}{\partial t} =\frac{\partial I}{\partial x} u+\frac{\partial I}{\partial y} v \\
=\left[\frac{\partial I}{\partial x}, \frac{\partial I}{\partial y}\right] \left[\begin{array}{l}
u \\
v
\end{array}\right]
$$

\begin{equation}
-I_t=\nabla I^T\mathbf{u}
\end{equation}

where $$I_t$$ is the temporal image gradient, and $$I_x$$ and $$I_y$$ are the spatial image gradients. For each image in our sequence, we want to find its temporal and spatial gradients and solve for $$\mathbf{u}$$.

This [zip file]({{"/assets/labs/bus.zip" | relative_url}}){:target="_blank"} contains the resources needed to complete this lab.

<h4>0. Capturing images with OpenCV</h4>

The following code grabs frames from a camera and displays them in a new window.

````python
import cv2
cam = cv2.VideoCapture(0, cv2.CAP_FIREWIRE) #Remove second arg if using webcam
while True:
    ret_val, img = cam.read()
    cv2.imshow('test', img)
````

Modify this code to use imwrite to save a sequence of images we will use for this lab. 

<h4>1. Finding our gradients (20) - complete the following steps for one timestep</h4>
a) Temporal Image Gradient<br>
Convert a sequenced pair of images to grayscale. Find the temporal difference between the two images. Threshold the temporal derivative by setting values that do not meet our threshold to zero.
Test different threshold values until motion is isolated and noise is minimized. __Display these results in your report.__
<br><br>
__Report question 1a: What does the temporal image gradient tell us about our image pair?__

b) Spatial Image Gradient<br>
Find the spatial image gradients along the $$x$$ and $$y$$ directions by taking the derivative (see numpy.gradient) along the first and zero-th axes of our image, respectively. __Display these results in your report.__
<br><br>
__Report question 1b: What edges are prominent in each spacial gradient?__

<h4>2. Solving for Optical Flow (40) - complete the following steps for one timestep</h4>
a) Tiling the image<br>
Divide our image into tiles of size block_size x block_size. Make sure our image is divisible by block_size (16, 32, etc.) and that the tiles do not overlap. Using numpy.meshgrid may help you find the borders of each tile.
<br><br>
__Report question 2a: How does changing block_size affect our results? What is one benefit and drawback of increasing block_size?__

b) Checking for motion<br>
For each tile, check for motion by solving for $$\mathbf{u}=[u,v]^T$$ using the least squares solution to Equation 1. Ensure you flatten each vector ($$I_t, I_x, I_y$$) into column vectors before solving. Store each $$u$$ and $$v$$ into their own respective 2D array (these will be the U and V arguments for quiver).
<br><br>
__Report question 2b: What are the dimensions of our U and V vectors that store each motion vector?__


c) Plotting<br>
For each tile, plot the motion vector $$\mathbf{u}$$ onto the centre of the tile using matplotlib.pyplot.quiver. __Display these results in your report.__

<h4>3. Optical flow on a video (40) </h4>
a) With our provide image sequence, repeat our optical flow algorithm and save the results into a video to include in your submission.<br>
b) Repeat with a recording of your own.
<br><br>
__Report question 3: What sort of motion have we captured here? Name two types of motion we cannot account for with our current method.__

<h4>4. Bonus (20) - Higher dimensional motion</h4>
Try to extract 4-dof motion (x, y, rotation and scale) or 6-dof motion (affine). Validate your solution by warping each tile based on the extracted motion parameters. Compare performance to warping with our 2-dof optical flow algorithm.
<br><br>
__Report question 4: How do your warping results compare between the 2-dof and higher dof motion extractions?__

<font color ='green'>Grad students: Celebrate! There is no additional work for you this week.</font>

<br><br>
