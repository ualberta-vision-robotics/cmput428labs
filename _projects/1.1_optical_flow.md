---
layout: page
title: Lab 1.1 Optical Flow
description:
permalink: /labs/opticalflow
img: assets/img/opticalflow.gif
importance: 1
category: Motion Estimation and Tracking
related_publications: false
---

<div class="row justify-content-md-center">
    <div class="col-sm-3 mt-4 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/opticalflow.gif" title="optical flow" class="img-fluid rounded z-depth-1"  %}
    </div>
</div>
<div class="caption">
    2 DOF optical flow on a soccer ball.
</div>

In this lab, you'll implement a basic 2-DoF optical flow algorithm. These flow vectors describe the motion in a scene. Equation 1 is the basis of optical flow. We can capture the temporal shift between two frames by using a first order approximation:

<!-- $$I(x, y, t)$$ gives the intensity at a point over time. We can approximate how the image intensity function changes over time with a Taylor series expansion:



$$
I(x+u, y+v, t+\Delta t)=I(x, y, t)+\frac{\partial I}{\partial x} u+\frac{\partial I}{\partial y} v+\frac{\partial I}{\partial t} \Delta t+\text { h.o.t. }
$$

With the brightness constancy and small motion assumptions, we can cancel out $$I$$ from both sides, yielding:

$$
-\frac{\partial I}{\partial t} =\frac{\partial I}{\partial x} u+\frac{\partial I}{\partial y} v \\
=\left[\frac{\partial I}{\partial x}, \frac{\partial I}{\partial y}\right] \left[\begin{array}{l}
u \\
v
\end{array}\right]
$$ -->

\begin{equation}
-I_t=\nabla I^T\mathbf{u}
\end{equation}

where $$I_t$$ is the temporal image gradient, and $$I_x$$ and $$I_y$$ are the spatial image gradients. For each image in our sequence, we want to find its temporal and spatial gradients and solve for $$\mathbf{u}$$.

This [zip file]({{"/assets/labs/bus.zip" | relative_url}}){:target="_blank"} contains the resources needed to complete this lab.

<h4>0. Capturing images with OpenCV</h4>

The following code grabs frames from a camera and displays them in a new window.

````python
import cv2
cam = cv2.VideoCapture(0, cv2.CAP_FIREWIRE) #Remove second arg if using webcam
while True:
    ret_val, img = cam.read()
    cv2.imshow('test', img)
````

Modify this code to use imwrite to save a sequence of images we will use for this lab. 

<h4>1. Single Window Optical Flow (20) - complete the following steps for one timestep</h4>
a) Temporal Image Gradient
<br>
Convert a sequenced pair of images to grayscale. Find the temporal difference between the two images. Threshold the temporal derivative by setting values that do not meet our threshold to zero.
Test different threshold values until motion is isolated and noise is minimized. 
<br>
__Display the final thresholded temporal derivative in your report.__
<br>
__Report question 1a: What does the temporal image gradient tell us about our image pair?__
<br>

b) Spatial Image Gradient
<br>
Find the spatial image gradients $$I_x$$ and $$I_y$$ (see numpy.gradient) along the first and zero-th axes of our image, respectively. 
<br>
__Display these results in your report.__
<br>
__Report question 1b: What edges are prominent in each spacial gradient?__
<br>

c) Solve for $$\mathbf{u}=[u,v]^T$$. Plot $$\mathbf{u}$$ onto the center of our image using matplotlib.pyplot.quiver. 
<br>
__Display these results in your report.__
<br>
<br>

<h4>2. Single Window Optical Flow Video (20)</h4>
a) Repeat the single window optical flow steps on this video. 
<br>
__Save these results to include in your submission__
<br>
__Report question 2a: What is one limitation of finding a single optical flow vector on the entire window?__
<br>
<br>

<h4>3. Optical Flow on Patches (20) - complete the following steps for one timestep</h4>
a) Divide our gradients into patches of size block_size x block_size. Ensure you choose a block_size divisible into our image dimensions (8, 16, 32 etc.). Using numpy.meshgrid may help you find the borders of each tile.
<br>
__Report question 3a: How does changing block_size affect our results? What is one benefit and drawback of increasing block_size?__
<br>

b) Find flow vectors for each tile. Store each $$u$$ and $$v$$ into their own respective 2D array (these will be the U and V arguments for quiver).
<br>
__Report question 3b: What are the dimensions of our U and V arrays that store each motion vector (Give answer w.r.t. image dimensions and block_size)?__
<br>

c) Plotting
<br>
For each tile, plot the motion vector $$\mathbf{u}$$ onto the centre of the tile using matplotlib.pyplot.quiver. 
<br>
__Display these results in your report.__
<br>
<br>

<h4>4. Optical flow video (20) </h4>
a) With our provided image sequence, apply our optical flow algorithm. 
<br>
__Save these results to include in your submission.__
<br>

b) Repeat with a recording of your own.
<br>
__Save these results to include in your submission.__
<br>

c) Implement a live instance of optical flow using cam.read().
<br>
__Report question 4: What sort of motion have we captured here? Name two types of motion we cannot account for with our current method.__
<br>
<br>

<h4>5. Rotation and Scale (20)</h4>
a) Find rotation and scale gradients ($$I_r$$ and $$I_s$$) for a single image.
<br>
__Display these results in your report__
<br>

b) Solve motion vectors $$r$$ and $$s$$ using a formulation similar to Equation 1 in a single window (i.e. no tiles) of a video that has rotation and zoom with respect to camera axis. Plot your results by mapping the x-vector to rotation and the y-vector to scale.
<br>
__Save these results to include in your submission__
<br>

<br>

<!-- should we do a bonus? -->

<!-- <h4>5. Bonus (20) - Higher dimensional motion</h4>
Try to extract 4-dof motion (x, y, rotation and scale) or 6-dof motion (affine). Validate your solution by warping each tile based on the extracted motion parameters. Compare performance to warping with our 2-dof optical flow algorithm.
<br><br>
__Report question 4: How do your warping results compare between the 2-dof and higher dof motion extractions?__ -->

<font color ='green'>Grad students: Celebrate! There is no additional work for you this week.</font>
<br>
<br>

<h4>Submission Details</h4>
<!-- talk about submission details (expected files, naming format, etc.) -->

<br>
<br>
